function [stim2_im_nr, stim2_is_lure, stim2_is_match] = vcd_getLTMTestStim(params,cond_table)
% VCD function to assign special core stimuli with test stimuli 
% to form correct and incorrect (lure & non-lure) pairings. 
% Stim A is the stimulus shown before the delay period. 
% Stim B is shown after the delay period (=test stimulus, listed as stim2) 
% Trials for classic stimuli are not shuffled across stimulus classes 
% (we assume we will do this later).
%
%  [stim2_im_nr, stim2_is_lure] = vcd_getLTMTestStim(params,cond_table)
%
% INPUTS:
%  params      : (struct) general parameters struct generated by vcd_getSessionParams.m  
%  cond_table  : (table) condition table with unique conditions for a particular
%                stimulus-LTM crossing.
%
% OUTPUTS:
%  stim2_im_nr    : (matrix) stimulus numbers for test stimuli (trials x 2), 
%                     column 1 = left stim location, column 2 = right stim location.
%                     order of trials matches those in cond_table.
%  stim2_is_lure  : (matrix) indicate if the incorrect test stimulus (b) for 
%                     that particular trial is a lure (1) or not (0), 
%                     dimensions are trials x 2.
%                     column 1 = left stim location, column 2 = right stim location.
%  stim2_is_match : (matrix) indicate if the test stimulus (b) matches reference stim (a) 
%                     dimensions are trials x 2. (0 = no match, 1 = match)
%                     column 1 = left stim location, column 2 = right stim location.
%                    
%
% Terminology:
% * Lures are incorrect test stimuli (B):
%   In case of classic stim: stim2 is sampled from a list of special core stimuli from the same stimulus class as the paired test stimulus.
%     For example, for a correct pair (A-B): Gabor 17 (A) - OBJ 80 (B), the lure for Gabor 17 (A) can be OBJ 81 (B)
%   In case of NS: stim2 is sampled from a list of special core NS stimuli from the same object super-category as the paired test NS stimulus.
%     For example, for a correct pair (A-B): NS cat1 (A) - NS house1 (B), the lure for NS cat1 (A) can be other NS with cats/girraffes (B)

% * Non-lures are incorrect test stimuli,
%   In case of classic stim: stim2 is sampled from a list of special core stimuli from different stimulus classes than the correct test stimulus (B).
%     For example, for a correct pair (A-B): Gabor 17 (A) - OBJ 80 (B), the non-lure for Gabor 17 (A) can be DOT 41 (B)
%   In case of NS: stim2 is sampled from a list of special core NS stimuli from the other object super-category as the paired test NS stimulus.
%     For example, for a correct pair (A-B): NS cat1 (A) - NS house1 (B), the non-lure for NS cat1 (A) can be NS with faces, objects, foods, places (B)    
%
% This function will do the following:
% 1. Determine associated unique stimulus number (B) for each special core stimulus (A)
% 2. Determine the other, non-paired stimuli (and their unique stim number).
% 3. Get number of correct vs incorrect trials (and for incorrect trials: lures vs nonlures)
% 4. Assign stimulus numbers accordingly, using random sampling without
%    replacement from the predetermined list of stimulus numbers.
%
% Edge cases: if we have an uneven number of incorrect trials, then we round 
% the number of left and right incorrect trials to the nearest number, and 
% adjust the number of lures/nonlures accordingly. We toss a coin (rand < 0.5 or >= 0.5) 
% to do determine which side we will round (cued or uncued side), independently 
% for both rleft and right stimulus locations.
%
% Written by Eline Kupers @ UMN (Jan 2026)

% Check: all trials should be LTM crossings
assert(all(cond_table.task_class == 6)); 

% define non-catch trials
noncatch_trials_idx = ~cond_table.is_catch;

cond_table0 = cond_table(noncatch_trials_idx,:);

if all(cond_table0.stim_class==5) % NS
    
    % determine associated stimulus (B) paired with gabor special core stimulus (A)
    [~,ltm_idx] = ismember(cond_table0.stim_nr_left,params.stim.ns.ltm_pairs(:,1));
    ltm_pairs   = [cond_table0.stim_nr_left, params.stim.ns.ltm_pairs(ltm_idx,2)];
    [~,ltm_idx_B] = ismember(params.stim.ns.ltm_pairs(ltm_idx,2),params.stim.ns.unique_im_nrs_specialcore);

    % Determine the other, non-paired stimuli:
    % * Lures are incorrect test stimuli (B), in case of NS: from the same object super-category as the paired test stimulus.
    % For example, for a correct pair (A-B): NS cat1 (A) - NS house1 (B), the lure for NS cat1 (A) can be other NS with cats/girraffes (B)
    % * Non-lures are incorrect test stimuli, in case of NS: from the other object super-category as the paired test stimulus.
    % For example, for a correct pair (A-B): NS cat1 (A) - NS house1 (B), the non-lure for NS cat1 (A) can be NS with faces, objects, foods, places (B)
    [~,ltm_idx_all] = ismember(cond_table0.stim_nr_left,params.stim.all_ltm_pairs(:,1));
    ltm_stimclass  = params.stim.all_ltm_pairs_stim_class(ltm_idx_all,:);
    [~,ltm_stimclass_all]  = ismember(params.stim.ns.ltm_cat, params.stim.ns.super_cat);
    [~,ltm_supercatA]  = ismember(params.stim.ns.ltm_cat(ltm_idx), params.stim.ns.super_cat);
    [~,ltm_supercatB]  = ismember(params.stim.ns.ltm_cat(ltm_idx_B), params.stim.ns.super_cat);
    assert(isequal(ltm_supercatA,cond_table0.super_cat(:,1)))
    
    % first column should be ns
    assert(all(ltm_stimclass(:,1)==5));
    
    tmp_sc_nr = NaN(size(cond_table0,1),4); % dims: N trials x 4 cols: [#A #B stimcatA stimcatB]
    tmp_sc_nr(:,[1,2]) = ltm_pairs;
    tmp_sc_nr(:,[3,4]) = [ltm_supercatA,ltm_supercatB];
    
    % Find special core stim that have the same super-class object category
    lures    = NaN(size(tmp_sc_nr,1), 3); % probe stim x 3 stim numbers
    nonlures = NaN(size(tmp_sc_nr,1), 11); % probe stim x 11 stim numbers

    for ii = 1:size(tmp_sc_nr,1) % loop over trials in condition table.
        
        if all(~isnan(tmp_sc_nr(ii,:)))
            
            % get paired test stimulus and stimulus class
            xx = squeeze(tmp_sc_nr(ii,:));
            
            % find other NS test stimuli from the same super-class object categoriy as test stim (B)
            lures0 = params.stim.ns.ltm_pairs(ismember(ltm_stimclass_all, xx(4)),1);
            
            % remove the probe and correct test stimulus from the lures list.
            lures1 = setdiff(lures0,[xx(1),xx(2)]);
            
            % add to lures list (2D matrix: trial nr x nr of lures)
            lures(ii,1:length(lures1)) = lures1(randperm(length(lures1),length(lures1))); % shuffle lure trial order
            
            % find other NS test stimuli from different super-class object categories than the test stim (B)
            nonlures0 = params.stim.ns.ltm_pairs(~ismember(ltm_stimclass_all, xx(4)),1);
            
            % remove the probe stim and test stim from the nonlures list.
            nonlures1 = setdiff(nonlures0,[xx(1),xx(2)]);
            
            % add to nonlures list (2D matrix: trial nr x nr of lures)
            nonlures(ii,1:length(nonlures1)) = nonlures1(randperm(length(nonlures1),length(nonlures1))); % shuffle non-lure trial order
        end
    end
    
    
    % get number of correct vs incorrect trials (and for
    % incorrect trials: lures vs nonlures)
    nr_correct_trials           = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_correct_pair; % 50% chance of a given stim-stim pair in a trial is correct
    nr_incorrect_trials         = size(cond_table0.stim2_im_nr,1)*(1-params.exp.trial.ltm.prob_correct_pair); % 50% chance of a given stim-stim pair in a trial is incorrect
    nr_incorrect_lure_trials    = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_incorrect_pair_same_stimclass; % 25% percent incorrect of trials are lures (test image is from same stimulus class)
    nr_incorrect_nonlure_trials = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_incorrect_pair_diff_stimclass; % 25% percent of trials are non-lures (test image is from different stimulus class)
    assert(isequal(sum([nr_correct_trials,nr_incorrect_trials]),size(cond_table0,1)));
    assert(isequal(sum([nr_incorrect_lure_trials,nr_incorrect_nonlure_trials]),nr_incorrect_trials));
    
    % if we have an uneven nr of incorrect trials, then we round the lures 
    % to the nearest number and adjust nonlures accordingly. This means 
    % that we end up with slightly more lures than nonlures.
    if mod(nr_incorrect_lure_trials,1)~=0
        random_selection = rand(1,1);
        if random_selection < 0.5 % round lures
            nr_incorrect_lure_trials    = round(nr_incorrect_lure_trials);
            nr_incorrect_nonlure_trials = nr_incorrect_trials-nr_incorrect_lure_trials;
        else % round nonlures
            nr_incorrect_nonlure_trials = round(nr_incorrect_nonlure_trials);
            nr_incorrect_lure_trials    = nr_incorrect_trials-nr_incorrect_nonlure_trials;
        end
    end
    
    % assign correct/incorrect trials for NS stim
    corr_idx_cued            = datasample(1:size(cond_table0.stim2_im_nr,1),nr_correct_trials,'Replace',false); % assign correct trials 
    incorr_idx_cued          = setdiff(1:size(cond_table0.stim2_im_nr,1),corr_idx_cued); % assign incorrect trials 
    incorr_lure_idx_cued     = incorr_idx_cued(datasample(1:length(incorr_idx_cued),nr_incorrect_lure_trials,'Replace',false));
    incorr_nonlure_idx_cued  = setdiff(incorr_idx_cued,incorr_lure_idx_cued);
      
    
    % do some checks re sampled correct/incorrect trials
    assert(all(ismember(corr_idx_cued,incorr_idx_cued)==0)); % trials that are correct and incorrect should not overlap.
    assert(all(ismember(incorr_lure_idx_cued,incorr_nonlure_idx_cued)==0)); % trials that are lures vs non-lures should not overlap.
    assert(all(ismember(corr_idx_cued,[incorr_lure_idx_cued,incorr_nonlure_idx_cued])==0)); % trials that are lures & non-lures should not overlap correct trials.
    assert(isequal(length(incorr_idx_cued),length([incorr_lure_idx_cued,incorr_nonlure_idx_cued]))); % nr of lures & non-lures trials equals nr of incorrect trials.
    if sum(noncatch_trials_idx==0)>0
        assert(ismember(length(corr_idx_cued),length(incorr_idx_cued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
        if mod(nr_incorrect_lure_trials,1)==0
            assert(ismember(length(incorr_lure_idx_cued),length(incorr_nonlure_idx_cued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
        else
            assert(ismember(length(incorr_lure_idx_cued),length(incorr_nonlure_idx_cued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
        end
    else
        if nr_incorrect_lure_trials==nr_incorrect_nonlure_trials
            assert(isequal(length(corr_idx_cued),length(incorr_idx_cued)))
            assert(isequal(length(incorr_lure_idx_cued),length(incorr_nonlure_idx_cued)))
        elseif nr_incorrect_lure_trials~=nr_incorrect_nonlure_trials
            assert(ismember(length(corr_idx_cued),length(incorr_idx_cued)+[-1:1]))
            assert(ismember(length(incorr_lure_idx_cued),length(incorr_nonlure_idx_cued)+[-1:1]))
        else
            error('wtf')
        end
    end
    stim2_im_nr0    = NaN(size(cond_table0,1),1); % only one central stim
    stim2_is_lure0  = NaN(size(cond_table0,1),1); % only one central stim
    stim2_is_match0 = NaN(size(cond_table0,1),1);  % only one central stim
    
    for tt = 1:size(cond_table0,1)
        
        stim2_nr = []; is_lure = []; is_match = [];
        
        % Catch trials
        if cond_table0.is_catch(tt)==1
            assert(all(reshape(isnan(tmp_sc_nr(tt,:)),1,[])))
            stim2_nr        = NaN;
            is_lure         = NaN;
            is_match        = NaN;
        elseif cond_table0.is_cued(tt) == 3 % both-sides are cued

            % if it is a correct ltm trial..
            if ismember(tt,corr_idx_cued)
                assert(~ismember(tt,incorr_idx_cued)) % then it should not be an incorrect ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(tt,1)))); % check if stim1 (A) matches condition table
                
                % central stim (both-cued)
                stim2_nr = squeeze(tmp_sc_nr(tt,2));
                is_lure  = 0;
                is_match = 1; % stim pair matches
                % if it is an incorrect ltm trial..
            elseif ismember(tt,incorr_idx_cued)
                assert(~ismember(tt,corr_idx_cued)) % then it should not be a correct ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(tt,1)))); % check if stim1 (A) matches condition table
                
                is_match = 0; % stim pair does not match
                
                % check if this is a lure or non-lure trial.
                if ismember(tt,incorr_lure_idx_cued) % lures
                    curr_lure_list     = lures(tt,~isnan(lures(tt,:)));
                    if isempty(curr_lure_list)
                        error('[%s]: Lure list is empty!', mfilename)
                    end
                    stim2_nr        = curr_lure_list(1);
                    is_lure         = 1;
                    lures(tt,lures(tt,:)==curr_lure_list(1)) = NaN; % remove used lure from list
                    
                elseif ismember(tt,incorr_nonlure_idx_cued) % non-lures
                    curr_nonlure_list  = nonlures(tt,~isnan(nonlures(tt,:)));
                    if isempty(curr_nonlure_list)
                        error('[%s]: Non-lure list is empty!', mfilename)
                    end
                    stim2_nr(1)        = curr_nonlure_list(1);
                    is_lure(1)         = 0;
                    nonlures(tt,nonlures(tt,:)==curr_nonlure_list(1)) = NaN; % remove used lure from list
                else
                    error('wtf')
                end
            end
        else
            error('wtf')
        end
        
        stim2_im_nr0(tt)    = stim2_nr;
        stim2_is_lure0(tt)  = is_lure;
        stim2_is_match0(tt) = is_match;
    end
    assert(isequal(sum(stim2_is_lure0),length(incorr_lure_idx_cued)))
    assert(isequal(sum(stim2_is_lure0),nr_incorrect_lure_trials))
    assert(all(sum([stim2_is_lure0,stim2_is_match0],2)~=2))
    assert(all(stim2_im_nr0~=cond_table0.stim_nr_left))
    assert(isequal(stim2_im_nr0(corr_idx_cued),tmp_sc_nr(corr_idx_cued,2)))
    
    % insert back in matrix with catch trials
    stim2_im_nr    = NaN(size(cond_table,1),2);
    stim2_is_lure  = NaN(size(cond_table,1),2);
    stim2_is_match = NaN(size(cond_table,1),2);
    stim2_im_nr(noncatch_trials_idx,1)   = stim2_im_nr0;
    stim2_is_lure(noncatch_trials_idx,1) = stim2_is_lure0;
    stim2_is_match(noncatch_trials_idx,1) = stim2_is_match0;
    clear stim2_im_nr0 stim2_is_lure0 stim2_is_match0
    
else % classic stim
    
    curr_stim_class = unique(cond_table0.stim_class);
    curr_stim_class_name = unique(cond_table0.stim_class_name);
    
    % determine associated stimulus (B) paired with gabor special core stimulus (A)
    [~,ltm_idx_l] = ismember(cond_table0.stim_nr_left,params.stim.(curr_stim_class_name{1}).ltm_pairs(:,1));
    [~,ltm_idx_r] = ismember(cond_table0.stim_nr_right,params.stim.(curr_stim_class_name{1}).ltm_pairs(:,1));
    ltm_pairs_l   = [cond_table0.stim_nr_left, params.stim.(curr_stim_class_name{1}).ltm_pairs(ltm_idx_l,2)];
    ltm_pairs_r   = [cond_table0.stim_nr_right, params.stim.(curr_stim_class_name{1}).ltm_pairs(ltm_idx_r,2)];
    
    [~,ltm_idx_l_all] = ismember(cond_table0.stim_nr_left,params.stim.all_ltm_pairs(:,1));
    [~,ltm_idx_r_all] = ismember(cond_table0.stim_nr_right,params.stim.all_ltm_pairs(:,1));
    
    % add stim location (1=left, 2=right)
    ltm_all_stim_loc = NaN(size(params.stim.all_ltm_pairs,1),2);
    tmp = vcd('fullinfo',params.stim.all_ltm_pairs(:,1));
    ltm_all_stim_loc(:,1) = cat(1,tmp(:).stim_loc);
    tmp = vcd('fullinfo',params.stim.all_ltm_pairs(:,2));
    ltm_all_stim_loc(:,2) = cat(1,tmp(:).stim_loc);
    assert(all(ltm_all_stim_loc(:,1)==ltm_all_stim_loc(:,2)))
    
    % Determine the other, non-paired stimuli:
    % * Lures are incorrect test stimuli (B), from the same stimulus class as the paired test stimulus.
    % For example, for a correct pair (A-B): Gabor 17 (A) - OBJ 80 (B), the lure for Gabor 17 (A) can be OBJ 81 (B)
    % * Non-lures are incorrect test stimuli, from different stimulus classes than the correct test stimulus (B).
    % For example, for a correct pair (A-B): Gabor 17 (A) - OBJ 80 (B), the non-lure for Gabor 17 (A) can be DOT 41 (B)
    ltm_stimclass_l = params.stim.all_ltm_pairs_stim_class(ltm_idx_l_all,:);
    ltm_stimclass_r = params.stim.all_ltm_pairs_stim_class(ltm_idx_r_all,:);
    
    % first column should all be classic stim 
    assert(all(ltm_stimclass_l(:,1)==curr_stim_class));
    assert(all(ltm_stimclass_r(:,1)==curr_stim_class));
    
    tmp_sc_nr = NaN(2,size(cond_table0,1),4); % dims: 2 stim loc (1=left,2=right) x 16 trials x 4 cols: [#A #B stimclassA stimclassB]
    tmp_sc_nr(1,:,[1,2]) = ltm_pairs_l;
    tmp_sc_nr(1,:,[3,4]) = ltm_stimclass_l; % col 3 = all same stim class (gabors = 1, rdk = 2, dot = 3, obj = 4)
    tmp_sc_nr(2,:,[1,2]) = ltm_pairs_r;
    tmp_sc_nr(2,:,[3,4]) = ltm_stimclass_r; % col 3 = all same stim class (gabors = 1, rdk = 2, dot = 3, obj = 4)
    
    % Find special core stim that have the same stimulus
    % class, but are not the same as associated stim that is paired.
    % for both left/right side stim.
    lures    = NaN(2,size(tmp_sc_nr,1), 3); % stimloc (left/right) x probe stim x 3 stim numbers
    nonlures = NaN(2,size(tmp_sc_nr,1), 8); % stimloc (left/right) x probe stim x 8 stim numbers
    
    for jj = [1,2] % idx into left/right stim columns
        for ii = 1:size(tmp_sc_nr,2)
            
            if all(~isnan(squeeze(tmp_sc_nr(jj,ii,:))))
                % get paired test stimulus and stimulus class
                xx = squeeze(tmp_sc_nr(jj,ii,:));
                
                % find other classic test stimuli from the same stimulus
                % class as test stim (B) and same stim location (left or right)
                lures0 = params.stim.all_ltm_pairs(ismember(params.stim.all_ltm_pairs_stim_class(:,1),xx(4)) & ismember(ltm_all_stim_loc(:,2),jj));
                
                % remove the correct test stimulus from the lures list.
                lures1 = setdiff(lures0,[xx(1),xx(2)]);
                
                % add to lures list
                lures(jj,ii,:) = lures1(randperm(length(lures1),length(lures1))); % shuffle lure trial order
                
                % find other classic test stimuli from the
                % diferent stimulus class as test stim (B), and
                % nor reference stim (a), and same stim location (left or right)
                nonlures0 = params.stim.all_ltm_pairs(~ismember(params.stim.all_ltm_pairs_stim_class(:,2),[xx(3:4)',5]) & ismember(ltm_all_stim_loc(:,2),jj),2); % exclude scenes
                
                % remove the probe stim stimulus from the nonlures list.
                nonlures1 = setdiff(nonlures0,xx([1,2]));
                
                % add to nonlures list
                nonlures(jj,ii,:) = nonlures1(randperm(length(nonlures1),length(nonlures1))); % shuffle non-lure trial order
            end
        end
    end
    
    % get number of correct vs incorrect trials (and for
    % incorrect trials: lures vs nonlures)
    nr_correct_trials           = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_correct_pair; % 50% chance of a given stim-stim pair in a trial is correct
    nr_incorrect_trials         = size(cond_table0.stim2_im_nr,1)*(1-params.exp.trial.ltm.prob_correct_pair); % 50% chance of a given stim-stim pair in a trial is incorrect
    nr_incorrect_lure_trials    = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_incorrect_pair_same_stimclass; % 25% percent incorrect of trials are lures (test image is from same stimulus class)
    nr_incorrect_nonlure_trials = size(cond_table0.stim2_im_nr,1)*params.exp.trial.ltm.prob_incorrect_pair_diff_stimclass; % 25% percent of trials are non-lures (test image is from different stimulus class)
    assert(isequal(sum([nr_correct_trials,nr_incorrect_trials]),size(cond_table0,1)));
    assert(isequal(sum([nr_incorrect_lure_trials,nr_incorrect_nonlure_trials]),nr_incorrect_trials));

    lcued = find(cond_table0.is_cued==1);
    rcued = find(cond_table0.is_cued==2);
    
    % split correct trials amongst l/r cued stim
    if mod(nr_correct_trials,2)~=0 % if we have an uneven nr of trials..
        tmpA = round(nr_correct_trials/2);
        tmpB = [tmpA, nr_correct_trials-tmpA];
        tmpC = tmpB(randperm(2,2));
        nr_lcued_correct_trials = tmpC(1);
        nr_rcued_correct_trials = tmpC(2);
        
        tmpC = tmpB(randperm(2,2));
        nr_luncued_correct_trials = tmpC(1);
        nr_runcued_correct_trials = tmpC(2);
    else
        nr_lcued_correct_trials   = nr_correct_trials/2;
        nr_rcued_correct_trials   = nr_correct_trials/2;
        nr_luncued_correct_trials   = nr_correct_trials/2;
        nr_runcued_correct_trials   = nr_correct_trials/2;
    end
    
    nr_lcued_incorrect_trials = (nr_correct_trials - nr_lcued_correct_trials)/2;
    nr_rcued_incorrect_trials = (nr_correct_trials - nr_rcued_correct_trials)/2;
    nr_luncued_incorrect_trials = (nr_correct_trials - nr_luncued_correct_trials)/2;
    nr_runcued_incorrect_trials = (nr_correct_trials - nr_runcued_correct_trials)/2;
    
    % if we have an uneven nr of incorrect trials, then we round left/right
    % incorrect to the nearest number and adjust nonlures accordingly.
    % we toss a coin to do this randomly for cued/uncued sides, for both
    % left/right stim
    if mod(nr_lcued_incorrect_trials,1)~=0
        random_selection = rand(1,1);
        if random_selection < 0.5 % round incorrect lcued
            nr_lcued_incorrect_trials    = round(nr_lcued_incorrect_trials);
            nr_luncued_incorrect_trials  = nr_incorrect_trials-nr_lcued_incorrect_trials;
        else % round incorrect luncued
            nr_luncued_incorrect_trials = round(nr_luncued_incorrect_trials);
            nr_lcued_incorrect_trials   = nr_incorrect_trials-nr_luncued_incorrect_trials;
        end
    end
    
    if mod(nr_rcued_incorrect_trials,1)~=0
        random_selection = rand(1,1);
        if random_selection < 0.5 % round incorrect lcued
            nr_rcued_incorrect_trials    = round(nr_rcued_incorrect_trials);
            nr_runcued_incorrect_trials  = nr_incorrect_trials-nr_rcued_incorrect_trials;
        else % round incorrect luncued
            nr_runcued_incorrect_trials = round(nr_runcued_incorrect_trials);
            nr_rcued_incorrect_trials   = nr_incorrect_trials-nr_runcued_incorrect_trials;
        end
    end

    
    % assign correct/incorrect trials for left cued stim
    corr_idx_lcued            = datasample(lcued,nr_lcued_correct_trials,'Replace',false); % assign correct trials for left stim
    incorr_idx_lcued          = setdiff(lcued,corr_idx_lcued); % assign correct/incorrect trials for left stim
    incorr_lure_idx_lcued     = incorr_idx_lcued(datasample(1:length(incorr_idx_lcued),nr_lcued_incorrect_trials,'Replace',false));
    incorr_nonlure_idx_lcued  = setdiff(incorr_idx_lcued,incorr_lure_idx_lcued);
    % assign correct/incorrect trials for right cued stim
    corr_idx_rcued            = datasample(rcued,nr_rcued_correct_trials,'Replace',false); % assign correct trials for left stim
    incorr_idx_rcued          = setdiff(rcued,corr_idx_rcued);
    incorr_lure_idx_rcued     = incorr_idx_rcued(datasample(1:length(incorr_idx_rcued),nr_rcued_incorrect_trials,'Replace',false));
    incorr_nonlure_idx_rcued  = setdiff(incorr_idx_rcued,incorr_lure_idx_rcued);
    
    % assign correct/incorrect trials for left cued stim
    corr_idx_luncued            = datasample(rcued,nr_luncued_correct_trials,'Replace',false); % assign correct trials for left stim
    incorr_idx_luncued          = setdiff(rcued,corr_idx_luncued); % assign correct/incorrect trials for left stim
    incorr_lure_idx_luncued     = incorr_idx_luncued(datasample(1:length(incorr_idx_luncued),nr_luncued_incorrect_trials,'Replace',false));
    incorr_nonlure_idx_luncued  = setdiff(incorr_idx_luncued,incorr_lure_idx_luncued);
    
    % assign correct/incorrect trials for right cued stim
    corr_idx_runcued            = datasample(lcued,nr_rcued_correct_trials,'Replace',false); % assign correct trials for left stim
    incorr_idx_runcued          = setdiff(lcued,corr_idx_runcued);
    incorr_lure_idx_runcued     = incorr_idx_runcued(datasample(1:length(incorr_idx_runcued),nr_runcued_incorrect_trials,'Replace',false));
    incorr_nonlure_idx_runcued  = setdiff(incorr_idx_runcued,incorr_lure_idx_runcued);
    
    
    % do some checks re sampled correct/incorrect trials
    assert(all(ismember(corr_idx_lcued,incorr_idx_lcued)==0)); % trials that are correct and incorrect should not overlap.
    assert(all(ismember(incorr_lure_idx_lcued,incorr_nonlure_idx_lcued)==0)); % trials that are lures vs non-lures should not overlap.
    assert(all(ismember(corr_idx_lcued,[incorr_lure_idx_lcued,incorr_nonlure_idx_lcued])==0)); % trials that are lures & non-lures should not overlap correct trials.
    assert(isequal(length(incorr_idx_lcued),length([incorr_lure_idx_lcued;incorr_nonlure_idx_lcued]))); % nr of lures & non-lures trials equals nr of incorrect trials.
    assert(ismember(length(corr_idx_lcued),length(incorr_idx_lcued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
    assert(ismember(length(incorr_lure_idx_lcued),length(incorr_nonlure_idx_lcued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
    
    assert(all(ismember(corr_idx_rcued,incorr_idx_rcued)==0)); % trials that are correct and incorrect should not overlap.
    assert(all(ismember(incorr_lure_idx_rcued,incorr_nonlure_idx_rcued)==0)); % trials that are lures vs non-lures should not overlap.
    assert(all(ismember(corr_idx_rcued,[incorr_lure_idx_rcued,incorr_nonlure_idx_rcued])==0)); % trials that are lures & non-lures should not overlap correct trials.
    assert(isequal(length(incorr_idx_rcued),length([incorr_lure_idx_rcued;incorr_nonlure_idx_lcued]))); % nr of lures & non-lures trials equals nr of incorrect trials.
    assert(ismember(length(corr_idx_rcued),length(incorr_idx_rcued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
    assert(ismember(length(incorr_lure_idx_rcued),length(incorr_nonlure_idx_rcued)+([-1:1].*sum(noncatch_trials_idx==0)))); % nr of correct vs incorrect trials should be equal - catch trials
    assert(isequal(sort([corr_idx_lcued;incorr_idx_lcued;corr_idx_rcued;incorr_idx_rcued]),[1:size(cond_table0,1)]'))
    
    % transform mat 2 cell to deal with uneven number of allocated
    % lures/nonlures per trial when we delete the used stim from lure/nonlure list.
    lures = mat2cell(lures, ones(1,size(lures,1)), ones(1,size(lures,2)), size(lures,3));
    nonlures = mat2cell(nonlures, ones(1,size(nonlures,1)), ones(1,size(nonlures,2)), size(nonlures,3));
    
    stim2_im_nr0   = NaN(size(cond_table0,1),2);
    stim2_is_lure0 = NaN(size(cond_table0,1),2);
    stim2_is_match0 = NaN(size(cond_table0,1),2);
    
    for tt = 1:size(cond_table0,1)
        
        stim2_nr = [NaN, NaN]; is_lure = [NaN, NaN]; stim2_match = [NaN NaN];
        
        % Catch trials
        if cond_table0.is_catch(tt)==1
            assert(all(reshape(isnan(squeeze(tmp_sc_nr(:,tt,:))),1,[]))); % tmp_sc_nr dims: 2 stim loc (1=left,2=right) x 16 trials x 4 cols: [#A #B stimclassA stimclassB]
            stim2_nr = [NaN, NaN]; is_lure = [NaN, NaN]; stim2_match = [NaN NaN];
            
        elseif cond_table0.is_cued(tt) == 1 % left stim cued
            
            % LEFT STIM (CUED)
            % if it is a correct ltm trial..
            if ismember(tt,corr_idx_lcued)
                assert(~ismember(tt,incorr_idx_lcued)) % then it should not be an incorrect ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(1,tt,1)))); % check if stim1 (A) matches condition table
                
                % left stim (cued)
                stim2_nr(1) = squeeze(tmp_sc_nr(1,tt,2)); % 1=left x trial tt x #B
                is_lure(1)  = 0;
                stim2_match(1) = 1;
                % if it is an incorrect ltm trial..
            elseif ismember(tt,incorr_idx_lcued)
                assert(~ismember(tt,corr_idx_lcued)) % then it should not be a correct ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(1,tt,1)))); % check if stim1 (A) matches condition table
                stim2_match(1) = 0;
                % check if this is a lure or non-lure trial.
                if ismember(tt,incorr_lure_idx_lcued) % lures
                    stim2_nr(1)        = lures{1,tt}(1);
                    is_lure(1)         = 1;
                    lures{1,tt}(1)     = []; % remove used lure from list
                    
                elseif ismember(tt,incorr_nonlure_idx_lcued) % non-lures
                    stim2_nr(1)        = nonlures{1,tt}(1);
                    is_lure(1)         = 0;
                    lures{1,tt}(1)     = []; % remove used lure from list
                else
                    error('wtf')
                end
            else
                error('wtf')
            end
            
            % RIGHT STIM (UNCUED)
            % if it is a correct ltm trial..
            if ismember(tt,corr_idx_runcued)
                assert(~ismember(tt,incorr_idx_runcued)) % then it should not be an incorrect ltm trial
                assert(isequal(cond_table0.stim_nr_right(tt),squeeze(tmp_sc_nr(2,tt,1)))); % check if stim1 (A) matches condition table
                
                % right stim (uncued)
                stim2_nr(2) = squeeze(tmp_sc_nr(2,tt,2)); % third dim: first col = stim class, second col = stim nr
                is_lure(2)     = 0;
                stim2_match(2) = 1;
                % if it is an incorrect ltm trial..
            elseif ismember(tt,incorr_idx_runcued)
                assert(~ismember(tt,corr_idx_runcued)) % then it should not be an correct ltm trial
                assert(isequal(cond_table0.stim_nr_right(tt),squeeze(tmp_sc_nr(2,tt,1)))); % check if stim1 (A) matches condition table
                stim2_match(2) = 0;
                % check if this is a lure or non-lure trial.
                if ismember(tt,incorr_lure_idx_runcued) % lures
                    stim2_nr(2)        = lures{2,tt}(1);
                    is_lure(2)         = 1;
                    lures{2,tt}(1)     = [];
                    
                elseif ismember(tt,incorr_nonlure_idx_runcued) % non-lures
                    stim2_nr(2)        = nonlures{2,tt}(1);
                    is_lure(2)         = 0;
                    nonlures{2,tt}(1)  = [];
                else
                    error('wtf')
                end
            end
            
            
        elseif cond_table0.is_cued(tt) == 2 % right cued
            
            % RIGHT STIM (CUED)
            % if it is a correct ltm trial..
            if ismember(tt,corr_idx_rcued)
                assert(~ismember(tt,incorr_lure_idx_rcued)) % then it should not be an incorrect ltm trial
                assert(isequal(cond_table0.stim_nr_right(tt),squeeze(tmp_sc_nr(2,tt,1)))); % check if stim1 (A) matches condition table
                
                % left stim (cued)
                stim2_nr(2) = squeeze(tmp_sc_nr(2,tt,2));
                is_lure(2)  = 0;
                stim2_match(2) = 1;
                % if it is an incorrect ltm trial..
            elseif ismember(tt,incorr_idx_rcued)
                assert(~ismember(tt,corr_idx_rcued)) % then it should not be a correct ltm trial
                assert(isequal(cond_table0.stim_nr_right(tt),squeeze(tmp_sc_nr(2,tt,1)))); % check if stim1 (A) matches condition table
                stim2_match(2) = 0;
                % check if this is a lure or non-lure trial.
                if ismember(tt,incorr_lure_idx_rcued) % lures
                    stim2_nr(2)        = lures{2,tt}(1);
                    is_lure(2)         = 1;
                    lures{2,tt}(1)     = [];
                    
                elseif ismember(tt,incorr_nonlure_idx_rcued) % non-lures
                    stim2_nr(2)        = nonlures{2,tt}(1);
                    is_lure(2)         = 0;
                    nonlures{2,tt}(1)  = [];
                else
                    error('wtf')
                end
            end
            
            % LEFT STIM (UNCUED)
            % if it is a correct ltm trial..
            if ismember(tt,corr_idx_luncued)
                assert(~ismember(tt,incorr_lure_idx_luncued)) % then it should not be an incorrect ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(1,tt,1)))); % check if stim1 (A) matches condition table
                
                % right stim (uncued)
                stim2_nr(1) = squeeze(tmp_sc_nr(1,tt,2)); % third dim: first col = stim class, second col = stim nr
                is_lure(1)  = 0;
                stim2_match(1) = 1;
                % if it is an incorrect ltm trial..
            elseif ismember(tt,incorr_idx_luncued)
                assert(~ismember(tt,corr_idx_luncued)) % then it should not be a correct ltm trial
                assert(isequal(cond_table0.stim_nr_left(tt),squeeze(tmp_sc_nr(1,tt,1)))); % check if stim1 (A) matches condition table
                stim2_match(1) = 0;
                % check if this is a lure or non-lure trial.
                if ismember(tt,incorr_lure_idx_luncued) % lures
                    stim2_nr(1)        = squeeze(lures{1,tt}(1));
                    is_lure(1)         = 1;
                    lures{1,tt}(1)     = [];
                    
                elseif ismember(tt,incorr_nonlure_idx_luncued) % non-lures
                    stim2_nr(1)        = squeeze(nonlures{1,tt}(1));
                    is_lure(1)         = 0;
                    nonlures{1,tt}(1)  = [];
                else
                    error('wtf')
                end
            end
            
        end
        
        stim2_im_nr0(tt,:)   = stim2_nr;
        stim2_is_lure0(tt,:) = is_lure;
        stim2_is_match0(tt,:) = stim2_match;
    end
    
    % insert back in matrix with catch trials
    stim2_im_nr    = NaN(size(cond_table,1),2);
    stim2_is_lure  = NaN(size(cond_table,1),2);
    stim2_is_match = NaN(size(cond_table,1),2);
    stim2_im_nr(noncatch_trials_idx,:)    = stim2_im_nr0;
    stim2_is_lure(noncatch_trials_idx,:)  = stim2_is_lure0;
    stim2_is_match(noncatch_trials_idx,:) = stim2_is_match0;
end

return